[**@Iemprashant**](https://github.com/iemprashant/) ðŸš€
[**Striver Sheet question and solutions**](https://takeuforward.org/interviews/strivers-sde-sheet-top-coding-interview-problems/)âš¡

```
Day 1: Arrays
```

1. #### [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

   **Topic**:- Array | Hash Table | Matrix

   > **Approach**:

   1. Approach-1 => O((N*M)*(N + M))
      => For non negative elements, mark all zero to -1 and retraverse the row and column having -1( previously 0 ).
   2. Approach-2 => T-O(NM) + S-O(N)
      => Use row and col arry to mark for making row and col zero.
   3. Approach-3 => T-(NM) +S-O(1)-**BEST**
      =>Use zero row and col as flag, Use zerorow and zerocol var to store their status , now mark all row and col zero from 1->size, and if (zerorow)->mark row zero ,same with firstcol.

1. #### [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/)

   **Topic**:- Array | DP

   > **Approach**: T-O(N2).

   1. Make a 2d array of size(row given)
   2. traverse from i=0 to i < r ,also resize mat[i].resize(i+1).
   3. mat[i][0] = mat[i][i] = 1;
   4. for j=1 -> j<i => mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j];

1. #### [Next Permutation](https://leetcode.com/problems/next-permutation/)

   **Topic**:- Array | Two Pointer

   > **Approach**:

   1.
   2.
   3.

1. #### []()

   **Topic**:-

   > **Approach**:

   1.
   2.
   3.

1. #### []()

   **Topic**:-

   > **Approach**:

   1.
   2.
   3.

1. #### []()

   **Topic**:-

   > **Approach**:

   1.
   2.
   3.

```
Day 2: Arrays Part-II
```

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

```
Day 3: Arrays Part-III
```

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

```
Day 4: Arrays Part-IV
```

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### [Count number of subarrays with given Xor K](https://www.interviewbit.com/problems/subarray-with-given-xor/)

   **Topic**:- Array | Prefix Sum

   > **Approach**:

   1. Observe Prefix sum and store in the unordered_map.
   2. pre[A]^pre[B] = xor value of subarray (a->b)
   3. Use the idea of (subbarray sum equals k)

   **Related Question**

   1. [Subsets with XOR value](https://practice.geeksforgeeks.org/problems/subsets-with-xor-value2023/1#)
      ^Find subsets (not subarray)=> use backtracking with Dp , take or not take approach.

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

<--->Template

```

```

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-

1. #### []()

   **Topic**:-

   **Approach**:-
